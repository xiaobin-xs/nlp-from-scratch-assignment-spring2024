arXiv:2305.04154v1  [cs.AI]  7 May 2023Score: A Rule Engine for the Scone
Knowledge Base System
Jeffrey Chen
CMU-CS-21-116
May 2021
Computer Science Department
School of Computer Science
Carnegie Mellon University
Pittsburgh, PA 15213
Thesis Committee:
Scott E. Fahlman, Carnegie Mellon University
Computer Science Department and Language Technologies Ins titute
Alessandro Oltramari
Bosch Research & Technology Center, Pittsburgh
Submitted in partial fulﬁllment of the requirements
for the degree of Master of Science.
Copyright © 2021 Jeffrey Chen
Keywords: Scone, Knowledge Base System, Production Rule System, Prod uction System
Abstract
We present Score, a rule engine designed and implemented for the Scone knowl-
edge base system. Scone is a knowledge base system designed f or storing and ma-
nipulating rich representations of general knowledge in sy mbolic form. It represents
knowledge in the form of nodes and links in a network structur e, and it can perform
basic inference about the relationships between different elements efﬁciently. On its
own, Scone acts as a sort of “smart memory” that can interface with other software
systems. One area of improvement for Scone is how useful it ca n be in supplying
knowledge to an intelligent agent that can use the knowledge to perform actions and
update the knowledge base with its observations.
We augment the Scone system with a production rule engine tha t automatically
performs simple inference based on existing and newly-adde d structures in Scone’s
knowledge base, potentially improving the capabilities of any planning systems built
on top of Scone. Production rule systems consist of “if-then ” production rules that
try to match their predicates to existing knowledge and ﬁre t heir actions when their
predicates are satisﬁed. We propose two kinds of production rules, if-added and
if-needed rules, that differ in how they are checked and ﬁred to cover multiple use
cases. We then implement methods to efﬁciently check and ﬁre these rules in a
large knowledge base. The new rule engine is not meant to be a c omplex stand-
alone planner, so we discuss how it ﬁts into the context of Sco ne and future work on
planning systems.
iv
Acknowledgments
I would like to thank Professor Scott Fahlman for introducin g me to Scone and
providing me with guidance on how a rule engine in Scone shoul d be designed.
His insights on the overall structure of Scone as well as on ot her related work in
production systems were instrumental in helping me write th is thesis. I would also
like to thank Alessandro Oltramari for agreeing to take the t ime to be on the thesis
committee and for making corrections and commenting on area s of improvement for
this document. Lastly, I would like to thank my sister, my par ents, and my friends
for always giving me their support when I needed it.
vi
Contents
1 Introduction and Background 1
1.1 Scone . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1.1 Elements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1.2 Multiple Inheritance and Marker Passing . . . . . . . . . . . . . . . . . 3
1.1.3 Roles and Virtual Copy Semantics . . . . . . . . . . . . . . . . . . . . . 4
1.1.4 Multiple Contexts and Episodic Reasoning . . . . . . . . . . . . . . . . 5
1.2 Thesis Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
2 Related Work 7
2.1 Rule-Based Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.1.1 Soar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.1.2 ACT-R . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8
2.1.3 Other Related Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3 Scone Planning Systems 11
3.1 Production Rule Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.1.1 If-added and if-needed rules . . . . . . . . . . . . . . . . . . . . . . . . 12
3.2 Rule Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.2.1 If-added rule example . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.2.2 If-needed rule example . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
3.3 Recipe-Based Planner . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.4 Implementation Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4 Rule-Checking Engine 19
4.1 Rule-Checking Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.1.1 Rule Triggers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.1.2 Rule Variable Substitution . . . . . . . . . . . . . . . . . . . . . . . . . 20
4.1.3 Rule-Checking Search Algorithm . . . . . . . . . . . . . . . . . . . . . 22
4.2 End-to-end Example Rule Firing . . . . . . . . . . . . . . . . . . . . . . . . . . 23
4.2.1 If-needed Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 5
5 Conclusion and Future Work 27
Bibliography 29
vii
Appendix 31
viii
List of Figures
1.1 Scone elements visualized . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2 Role nodes visualized for the knowledge “Fido is a pet of J ohn.” Here{pet of
John}is a virtual copy of {pet}that{John}inherits from{person}. . . . . . . . 4
3.1 A diagram of the if-added ﬂying event rule with some of the relevant elements.
A and B are drawn with dashed circles to indicate that they are placeholders
for other elements. Solid lines indicate is-a links, and das hed lines indicate x-y-z
links (in this case a role has-link). The double lines indica te links that are created
when the rule action is ﬁred. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.2 A diagram of the if-needed meeting duration rule. The arr ows from A and B to
the node labeled f(A,B)indicate that A and B will be used for the computation,
and the double line from f(A,B)to “duration of C” represents the is-a link that
will be created and returned. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4.1 A visualization of an is-a type constraint trigger. Y is a bove B in the is-a hi-
erarchy, and has a trigger attached to it with pointers to rul e R and variable X.
Trigger activation is performed by matching A with X. . . . . . . . . . . . . . . 21
4.2 A visualization of an x-y-z-predicate trigger. Y is abov e B in the is-a hierarchy,
and has a trigger attached to it with pointers to rule R and var iables X and Z.
Trigger activation is performed by matching A with X and C wit h Z. . . . . . . . 21
4.3 A visualization of an if-needed rule trigger. Y is above B in the is-a hierarchy,
and has a trigger attached to it with pointers to rule R and var iable Z. Trigger
activation is performed by matching C with Z. An is-a link is c reated between
the resulting computation X and “the B of C” as part of the rule action. . . . . . . 21
4.4 Rule-Checking Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
4.5 A visualization of two trigger activations for the meeti ng example rule, one for
each of the x-y-z role predicates. . . . . . . . . . . . . . . . . . . . . . . . . . . 24
ix
x
Chapter 1
Introduction and Background
Scone [6, 8] is an open-source knowledge base system (KBS) de signed to store a large col-
lection of knowledge, including both general, common-sens e knowledge and domain-speciﬁc
knowledge. By using multiple inheritance and virtual copy s emantics, Scone’s knowledge base
contains a signiﬁcant amount of implicit knowledge, much mo re than what is explicitly deﬁned
in the knowledge network. Scone is also equipped with fast in ference capabilities implemented
with parallel marker-passing algorithms that can answer ba sic queries about the stored knowl-
edge [6]. Scone is implemented in Common Lisp and has been und er development in Carnegie
Mellon University’s (CMU’s) Language Technologies Instit ute since around 2003. A tutorial
book on the design and usage of Scone is in the process of being written. Until it is published,
more information about Scone can be found in Fahlman’s Knowl edge Nuggets blog [8].
By itself, Scone is not an intelligent agent that can make dec isions, but acts more as a “smart
memory” that can be used to inform other decision-making pro cesses. One of our long term
goals is to give Scone the ability to reason robustly about pl ans and actions that can be used
to guide an intelligent agent. The ERIS (Episodic Reasoning in Scone) subsystem of Scone
provides a starting point for representing episodic knowle dge (actions, events, sequences, and
plans) in Scone to make basic reasoning about it possible [7] . ERIS introduces an event type to
Scone representing knowledge about how a state can change, a long with some other machinery
to represent concepts like before and after or cause and effe ct of events.
A production rule system consists of a set of production rule s along with a working memory
that the rules can access. Each production rule has a left-ha nd-side precondition that tries to
match with the working memory and a right-hand-side action t hat makes modiﬁcations to the
memory or performs some other action. Production systems ha ve been used as planning systems
in cognitive architectures such as Soar [12, 13, 14] and ACT- R [1, 2]. However, these systems
use production systems for the full range of planning tasks, whereas we plan for different systems
to handle simple, lower-level inference and higher-level p lanning.
Our main contribution is Score , short for Scone Rule Engine , that uses production rules for
automatic planning and inference. This rule-based planner will handle checking and ﬁring for
lower-level inference tasks that are not handled by Scone’s other systems. We also provide
an overview of, but do not implement, a recipe-based planner that handles more complex and
higher-level planning based on breaking down a goal into sub goals and considering alternative
plans. We do this to clarify that the goal of the rule engine is to handle just simple automatic
1
elephant
(a) A nodeClyde elephantis-a
(b) An (is-a) linkdislikes
(c) A relation
Figure 1.1: Scone elements visualized
inferences, not all kinds of complex planning as is the case i n some other production systems.
As an example of what capabilities we want our rule engine to h ave, suppose we are using
Score to plan a trip, which can be represented as an event type . If we know that the vehicle used
in the trip is an airplane, then the trip involves ﬂying, wher eas if the vehicle used is a car, then
the trip involves driving. These inferences can be phrased i nformally as rules saying “if there is
a trip event and the vehicle used is an airplane, then the trip is a ﬂying event” and similarly for
the other inference. Our rule engine allows deﬁning these ru les and performing these inferences
to update the knowledge base automatically.
Before outlining the details of our contribution, we ﬁrst pr ovide the necessary background
knowledge for how Scone itself is structured.
1.1 Scone
1.1.1 Elements
The basic unit of knowledge in Scone is an element , which is represented as a Common Lisp
data structure. Scone elements are denoted using curly brac es. Elements are divided into three
categories: nodes ,links , and relations , as shown in Figure 1.1. A node represents a description of
some conceptual knowledge about the world, like {elephant}or{the mother of Clyde }. Alink
describes the relationship between different elements, li ke{Clyde is an elephant }or{I dislike
brussels sprouts}. There are many different kinds of links that say different t hings about the
elements they are connected to. A relation represents some template relationship that can be
instantiated to form special links called statement links. For example,{dislikes}is a relation,
and an instantiation {I dislike brussels sprouts }is a statement link.
A speciﬁc kind of node in Scone is the role node . Arole node is attached to another node,
called the owner node, and represents some concept that the o wner node may have or possess.
For example, a person may have a mother and a dish may have ingr edients, so we can have in
Scone that{mother}is a role node with owner {person}and{ingredient}is a role node with
owner{dish}.
Nodes are divided into type nodes andindividual nodes . A type node represents a typical
member of some set, like {elephant}represents a typical elephant. An individual node represents
a speciﬁc member of some set, like {Clyde the elephant }represents a speciﬁc elephant named
Clyde. These notions also extend to roles. A type role represents a typical role that the owner
may possess multiple of, like {ingredient}of a dish. An individual role represents a speciﬁc role
that the owner generally only possesses one of, like {mother}of a person.
2
Anintersection type is a type node that is the intersection of several different t ypes. For
example, the type {man}can be seen as the intersection of the types {male},{human}, and
{adult}. A deﬁned type is an intersection type that additionally has a predicate th at must be
satisﬁed for nodes to be an instance of that type. As we explor e later, we see that intersection
types can be seen as simple if-then rules: if an element is a {male}, a{human}, and an{adult},
then the element is a {man}.
Each link has a set of wires that control how links connect different elements together . Two
important wires are the A-wire and B-wire of a link. The A-wir e is connected to the ﬁrst element
referenced in the link, and the B-wire is connected to the sec ond element referenced in the link.
For example, in the link representing {Clyde is an elephant }, the A-wire is connected to {Clyde}
and the B-wire is connected to {elephant}.
This last example is an instance of a special kind of link call ed an is-a link . These links state
that the element connected to the A-wire is a more speciﬁc con cept of the element connected to
the B-wire. For example, an is-a link connecting {human}to{mammal}represents the knowl-
edge that a human is a speciﬁc kind of mammal. There are also eq links that state the elements
connected to the A-wire and B-wire are equivalent. The set of all is-a and eq links forms what
is called the is-a hierarchy. Going “up” the is-a hierarchy m eans going from the A-wire element
to the B-wire element of is-a links which leads to more genera l concepts, and going “down” the
is-a hierarchy means going from the B-wire element to the A-w ire element of is-a links which
leads to more speciﬁc concepts. Elements above a given eleme nt in the is-a hierarchy are called
itssuperiors , and elements below a given element are called its inferiors . Superiors that are type
nodes are called supertypes , and inferiors that are type nodes are called subtypes . (All superiors
are in fact supertypes because individual nodes cannot have any inferiors.) The topmost element
in the is-a hierarchy is a type called {thing}: all other concepts are more speciﬁc than {thing}.
1.1.2 Multiple Inheritance and Marker Passing
Scone supports multiple inheritance through its is-a hierarchy: each element can have any num-
ber of incoming and outgoing is-a links. Inheritance allows Scone to infer many facts about
the knowledge base that are not explicitly stated. For examp le, if the knowledge base contains
knowledge that birds are feathered and that a chicken is a typ e of bird, the fact that a chicken is
feathered is inherited from the bird type and can be inferred .
Scone also has cancel-links to support reasoning with excep tions. For example, we can have
in the knowledge base that {bird}is a subtype of{ﬂying thing}, since birds generally can ﬂy, and
that{penguin}is a subtype of{bird}. However, since penguins can’t ﬂy, we add a cancel-link
from{penguin}to{ﬂying thing}to indicate that we do notwant to inherit{ﬂying thing}from
{bird}. Cancelling is a complex topic that can occasionally lead to knowledge ambiguities, and
we do not deal with them extensively in the rule engine.
Scone uses a marker-passing system to perform efﬁcient infe rence and to handle inheritance
and virtual copying [6]. Each node in Scone is equipped with a ﬁxed set of marker bits that
can be turned on and off. These markers can be conditionally t urned on and off in parallel. For
example, if a set of nodes is marked with some marker m, we can look at all is-a links in parallel
and request for each one to mark the node attached to the B-wir e withmif the node attached to
the A-wire is marked with m. This operation takes all nodes marked with mand marks with mall
3
person animal
John pet
pet of John
Fido
Figure 1.2: Role nodes visualized for the knowledge “Fido is a pet of John.” Here {pet of John}
is a virtual copy of {pet}that{John}inherits from{person}.
nodes one level above them in the is-a hierarchy. By repeatin g this operation until no new nodes
are marked with m, we can quickly ﬁnd all nodes above a speciﬁc node in the is-a h ierarchy, and
this procedure is called an upscan . There is a corresponding procedure called downscan where
we mark all nodes below a speciﬁc node in the is-a hierarchy.
1.1.3 Roles and Virtual Copy Semantics
Role nodes give rise to special links called has links . When a new role is declared for an owner,
a new has link is also created with A-wire connected to the role node and B-w ire connected to
the owner node. This link signiﬁes that the owner type posses ses some element of the role type.
Any inferior of the role is called a player or a ﬁller, indicat ing that “the player is a role ﬁller of
the owner.”
Scone implements virtual copy semantics to handle complex knowledge about roles in a
consistent way [6]. When a new inferior of a type with several roles is created, the roles are
virtually copied through inheritance. This means that the n ew inferior is treated as if it has a
copy of each of the roles of its parent type, though no actual c opying is done. For example,
suppose a{pet}role is deﬁned with owner {person}. This creates a has-link {people have pets}.
An individual person {John}then inherits the has link and the {pet}role, creating a virtual copy
{pet of John}. To say that an individual {Fido}is a pet of John, we then simply add an is-a link
from{Fido}to{pet of John}. This is visualized in Figure 1.2, with solid arrows denotin g is-a
links and dashed arrows denoting has links.
Scone also contains some marker operations related to role n odes and relations. For role
nodes, there is a function that marks every node xsuch that xis a ROLE of OWNER for a
speciﬁed ROLE and OWNER, and a function that marks every node xsuch that PLAYER is a
ROLE of xfor a speciﬁed ROLE and PLAYER. For relations, there are func tions that marks
every node xsuch that “ xRELATION B” or “B RELATION x” is true when RELATION and
4
either A or B are speciﬁed.
Using these marker operations, we can efﬁciently answer a va riety of queries about the
knowledge base, such as if Clyde is an animal or if Clyde has an y siblings. These marker passing
operations will form the basis for checking if knowledge in S cone satisﬁes any production rules
that can potentially ﬁre. Virtual inheritance will also pla y a role in rule “trigger” activation.
1.1.4 Multiple Contexts and Episodic Reasoning
All knowledge in the Scone knowledge base exists under some context , which can be any Scone
element. By default, all knowledge exists in a large context called{general}. Scone implements
amultiple-context mechanism that can handle different knowledge existing in different c ontexts
and switching between contexts. Each element in Scone has a context-wire connected to a context
that denotes when the knowledge represented by that element exists or is valid.
To activate a context, a special context marker is placed on t he context element, then up-
scanned to all supertypes of the context. This allows Scone t o easily consider alternative “uni-
verses” that are mostly the same as our universe but with some differences. For example, sup-
pose we want to model knowledge about the Harry Potter univer se. We can create a {Harry
Potter universe}context that is a subtype of the {general}context. When activating the {Harry
Potter universe}context, we inherit all the knowledge in {general}, so many basic facts such as
“humans have two hands” are still true in this context. Howev er, we can add nodes and links
to just this context, such as {wizards can use magic }, that are only true when the {Harry Potter
universe}context is active. When we reactivate the {general}context, the context-wire of the
new nodes and links refer to the {Harry Potter universe }which no longer has the active context
marker, so they are inactive. Scone’s multiple-context mec hanism allows easy exploration of
different possible states containing slightly different k nowledge.
Episodic reasoning in Scone [7] depends heavily on the multi ple-context mechanism. Scone
has an{event}type that represents an event with a “before” state and an “af ter” state. We rep-
resent this by giving {event}two roles{before-context}and{after-context}. As their names
imply,{before-context}is a context containing knowledge that is true before the eve nt occurs,
and{after-context}correspondingly contains knowledge that is true after the e vent occurs. Gen-
erally, the{before-context}is inherited from the active context, meaning all the curren tly active
knowledge is valid before the event, and the {after-context}inherits from{before-context}and
makes a few modiﬁcations. As an example, suppose we have an ev ent representing a caterpillar
undergoing metamorphosis into a butterﬂy. In the before-co ntext, we would have an is-a link
from an individual to {caterpillar}, and in the after-context, we would cancel this link and have a
new is-a link from the individual to {butterﬂy}. Scone also has an {action}type, which is just a
special{event}that has an{agent}role representing something that causes the event. An agent
could be a{person}in an event like throwing a ball.
1.2 Thesis Structure
The remainder of the thesis is structured as follows. In Chap ter 2, we discuss related work in
production systems as they are used in cognitive architectu res. In Chapter 3, we design a structure
5
for production rules that is compatible with Scone, and we al so describe the recipe-based planner
to provide context for our design goals. Chapter 4 contains a description of rule triggers and a
rule search algorithm that are used to check and ﬁre these rul es efﬁciently with the knowledge
base. Finally, we conclude with future directions for resea rch in Chapter 5. Some concrete code
and a pointer to the rule engine codebase is provided in the Ap pendix.
6
Chapter 2
Related Work
2.1 Rule-Based Systems
Production rule systems have been used in existing cognitiv e architectures such as Soar and
ACT-R. In general, a production system consists of a set of ru les (or productions), which can be
thought of as if-then statements, and a mechanism for checki ng and ﬁring the rules. Production
systems assume some form of memory or knowledge that the prod uctions can read and modify.
The “if” part of a production deﬁnes some condition that must be matched by the current state
of the memory. If it is matched, the “then” part of that produc tion is ﬁred and executes some
action, which often includes modifying the current memory o r knowledge. After a production is
ﬁred, the memory can be modiﬁed to a state that matches the “if ” part of a different rule, causing
a chain of production rule ﬁrings.
This general structure leaves many parts of the system up to t he underlying architecture
to design and implement, such as how the memory is stored and m atched and what to do if
multiple production rules match the memory and can ﬁre. Both Soar and ACT-R use this same
general structure for their production systems, though the y address design questions such as these
differently and emphasize somewhat different parts of thei r systems.
2.1.1 Soar
Soar was ﬁrst developed by Allen Newell’s research group in t he CMU Department of Computer
Science, and work on Soar has continued primarily under John Laird at the University of Michi-
gan and Paul Rosenbloom at the University of Southern Califo rnia [12, 13, 14]. It is designed
to be a uniﬁed cognitive architecture, a theory that can expl ain how cognition works across a
wide range of tasks. Some of its key design objectives includ e being goal-oriented, meaning it
makes rational decisions in order to reach a deﬁned goal, and requiring use of large amounts of
knowledge and abstractions, which informs its decisions gi ven what it currently perceives about
the state.
Soar distinguishes between two kinds of memory: long-term m emory (LTM) and working
memory (WM). Long-term memory is further divided into proce dural, semantic, and episodic
knowledge, though procedural LTM is the main kind of knowled ge used in the rule system.
7
Procedural knowledge stores information about how and when to carry out tasks to reach a goal
and is phrased in terms of if-then production rules. Working memory contains information about
the current state, such as the goal and any relevant informat ion about the environment. Soar
additionally differentiates between rules andoperators : rules can augment the working memory
state and make suggestions about what operator to choose, wh ereas only operators can modify
knowledge stored in working memory.
LTM and WM work together to achieve a desired goal through a se quence of ﬁve phases:
input, elaboration, decision, application, and output. Th e input phase is when the goal is deﬁned
and knowledge about the starting state is brought into WM fro m a perception module. The
elaboration phase is when production rules in procedural LT M ﬁre. Since these rule actions are
monotonic, meaning they only augment the current WM with new information and suggestions
about what possible operator to take, all applicable rules f or the current state ﬁre in parallel. The
elaboration phase ends when no more rules can be ﬁred.
After the elaboration phase ends and the decision phase begi ns, the system considers all
of its suggested operators and chooses one to apply. The syst em makes a decision based on
some speciﬁcation of preferences, such as preferring one op erator over another or assigning each
operator a preference score and choosing the operator with t he highest score. After choosing an
operator, the system applies it to modify the working state i n the application phase. The output
phase consists simply of sending the operator to an output mo dule like one that controls motor
output.
2.1.2 ACT-R
ACT-R, short for Adaptive Control of Thought-Rational, is d eveloped primarily by John An-
derson’s research group in the CMU Department of Psychology [1, 2]. It is another cognitive
architecture that aims to model and explain the mental proce sses that are central to human cog-
nition. The key assumption in ACT-R is that there are two kind s of knowledge: declarative
knowledge and procedural knowledge. Declarative knowledg e is represented as “chunks,” struc-
tures with an isa pointer to what kind of fact it is and additio nal pointers to content in the fact.
Procedural knowledge is represented as production rules in the form of if-then statements.
In ACT-R, many different modules are responsible for proces sing different kinds of infor-
mation, such as a visual module for processing visual inform ation and a declarative module for
retrieving declarative knowledge. Within each module, pro cessing can be done in parallel, and
outputs are written to a small buffer. Writing data to and rea ding data from the buffers is serial,
creating communication bottlenecks between different mod ules. The modules are connected by
a central procedural module, which coordinates data from th e different buffers and processes
them with production rules. The procedural module is design ed to replicate cognitive mecha-
nisms linked to the basal ganglia in the brain, which is hypot hesized to take in information from
disparate regions of the brain and process them to make overa rching decisions.
The production system in the procedural module is designed s o that only a single production
rule can ﬁre at a time, creating a central bottleneck where th ere must be serial processing of
information at the procedural level. One reason to have this bottleneck is to prevent multiple
rules ﬁring and causing contradictory changes to the knowle dge; another is that there is evidence
from cognitive psychology suggesting a central bottleneck in human brains when processing
8
a problem state [3]. When multiple rules are applicable, the system chooses a rule with the
highest utility for some utility function. The procedural m odule completes tasks by reading in
information and applying production rules until the goal is reached. Researchers have conducted
experiments showing that human cognitive processing in a va riety of tasks can be replicated by
suitably designed ACT-R modules.
There has also been some research on integrating Scone with A CT-R [15]. In this research,
Oltramari and Lebiere add Scone as a knowledge module to ACT- R, creating ACT-RK (where
the K stands for Knowledge). The uniﬁed ACT-RK has improved k nowledge-based reasoning,
as was demonstrated when it was applied to the task of semanti cally describing visual input in
the form of video.
2.1.3 Other Related Work
Some rule systems, such as Prolog-based rule engines [4], us e backward chaining instead of for-
ward chaining. In Prolog systems, programs are built from fa cts and rules saying that a conclu-
sion is true if some premises are true. Execution is driven by a query, such as ?- animal(X).
asking what things are animals. Such a query causes backtrac king among the rules to ﬁnd a
resolution for the query, in this case outputting everythin g that can be deduced to be an animal
from the rules.
In systems with a large amount of knowledge and many rules, na ive rule pattern matching
is often too slow. One optimization is the Rete algorithm [10 ] that can improve matching per-
formance. The Rete algorithm builds a network of nodes conta ining tests for knowledge that
partially satisﬁes rule predicates. A path from a root to a le af indicates an entire rule predicate
that is satisﬁed. When new facts are added, they are propagat ed down the network, and any leaf
nodes that are reached indicate that the action is ready to ﬁr e.
The Scone system manages and stores semantic knowledge, tho ugh it is not the only semantic
knowledge network. The Semantic Web [11] is an extension to t he World Wide Web that enables
semantic analysis of data from web pages. It is comprised of s everal layers, including RDF (Re-
source Description Framework) and OWL (Web Ontology Langua ge). RDF makes statements
about data using subject-predicate-object triples. A coll ection of triples forms a network of infor-
mation about web resources. OWL is based on formal logic and c onsists of property assertions
about what kinds of relationships between different terms a re allowed. The structure of OWL can
be exploited by computer programs to verify logical consist ency and to make implicit knowledge
explicit through deduction.
9
10
Chapter 3
Scone Planning Systems
The long-term goal is to have two planning systems integrate d with Scone: one “rule-based”
planner and one “recipe-based” planner. The goal of the rule -based planner is to use productions
to perform fast automatic thinking, and the goal of the recip e-based planner is to be slower and
more deliberative in considering how to carry out the steps i n a “recipe plan.” Both kinds of
planners are valuable and complement each other: the rule-b ased planner can answer a large
range of simple queries and automatically augment its knowl edge, and the recipe-based planner
can leverage this knowledge to create more complex plans to a chieve its goals.
In this chapter, our main contribution is a design for produc tion rules that interfaces properly
with the knowledge structure of Scone. We have implemented t his design in Common Lisp code,
allowing the user to deﬁne new rules that can be added to the kn owledge base. Implementation of
the recipe-based planner is beyond the scope of this researc h and left to future work; we describe
how it should behave to illustrate that the rule-based plann er is not designed to carry out complex
planning.
Scone stores a rich representation of a large amount of knowl edge and makes that knowledge
simple to query for other applications built on top of it. In t hat sense, Scone has much in common
with the memory modules in Soar and ACT-R. More speciﬁcally, the Scone architecture with its
element structure can be seen as analogous to declarative kn owledge in ACT-R, and our new
production system corresponds to procedural knowledge in A CT-R. Scone can also be compared
to working memory in Soar, though much larger in scope as work ing memory is generally quite
small, and the new production system plays a similar role as S oar’s procedural long term memory.
One important distinction between the rule-based planner i n Scone and the production sys-
tems in Soar and ACT-R is that Soar and ACT-R depend on product ion rules to carry out complex
planning with goals. We expect the recipe-based planner to h andle goal-based planning, not the
rule-based planner. Correspondingly, our productions are not designed to work towards speciﬁc
goal states in mind but are instead meant to represent fast an d reﬂexive thinking.
3.1 Production Rule Design
The rule-based planner relies on production rules to perfor m fast and reﬂexive thinking. To this
end, we introduce a new kind of knowledge to the Scone knowled ge base system called a rule
11
(short for production rule). Scone rules are similar to ordi nary production rules in that they have
an “if” precondition, also known as the left-hand-side (LHS ) of the rule, and a “then” action,
also known as the right-hand-side (RHS). However, the analo gous “working memory” would be
the entire Scone knowledge base, which is quite different fr om the working memories of other
production systems because it is much larger, so the product ion rules must be structured to work
nicely with Scone and its various mechanisms.
The “if” part of a rule deﬁnes some predicates that must match with some portion of the
knowledge base in order to satisfy the rule. Matching in Scon e is a little more complicated than
simple pattern matching because inferiors in the is-a hiera rchy should also be considered when
matching. Since the Scone knowledge base is generally very l arge, we only want to consider a
localized portion of the knowledge base in a single rule. The most degenerate form of a rule only
considers a single element and speciﬁes some predicates abo ut it. For example, one possible rule
is that if an element is a {male}as well as an{adult}, then that element is a {man}. These rules
that only depend on a single element are in fact examples of Sc one’s existing deﬁned types or
intersection types, so deﬁned and intersection types can be seen as special cases of rules.
For rules that consider multiple elements in the LHS, the ele ments should be connected to
each other in some way through roles and/or relations. For ex ample, a rule could depend on a
meeting and the start time of that meeting, which would be two elements with one of them being
a role of another. Conceptually, a rule should say something about a local set of elements, so a
rule that depends on multiple elements that are not directly connected to each other through roles
or relations makes little sense.
The action of a rule deﬁnes what to do if the rule LHS is satisﬁe d by some set of elements.
An action can be something like adding links between some of t he elements in the rule. These
modiﬁcations to the knowledge base would fall under the acti ve context. An action could also
cause external actions such as motor movements if Scone is co nnected to a motor module. The
result of an action could cause the knowledge base to end up in a state that satisﬁes other rules,
leading to forward chaining of rules that each ﬁre consecuti vely.
3.1.1 If-added and if-needed rules
We separate Scone rules into two different classes: if-added rules and if-needed rules. If-added
rules, also called eager rules, are ﬁred when new links are added to the knowledge base .If-
needed rules, or lazyrules, are ﬁred when some value in the knowledge base is reque sted but not
found in the knowledge base, and they compute the requested v alue and save it in the knowledge
base as their action.
We distinguish between these two kinds of rules so that they c an serve slightly different
purposes. A rule should be an if-added (eager) rule if the act ion of the rule should be executed
immediately after the LHS is satisﬁed, whether because it co uld cause other rules to ﬁre or
because the action is urgent and needs immediate attention. If-added rules are more similar to
the production rules seen in existing production systems. T hey check if the memory, which in
Scone’s case is the entire knowledge base, matches their pre dicates, and they ﬁre their actions if
so. These actions can then change the memory, causing other r ules to match and ﬁre. We only
check if-added rules when new knowledge is added (hence thei r name of “if-added” rules), since
if the knowledge remains the same, the set of rules that are sa tisﬁed remains the same. Only
12
the addition of new knowledge can cause rules to ﬁre. When thi s happens, the system eagerly
ﬁres rules until it reaches a point where no further rules can ﬁre, at which point it pauses until
more knowledge is added in the future. The trade-off we are ma king with eager rules is that
adding new knowledge takes a little more time than before, bu t retrieving knowledge from the
knowledge base remains fast with no additional overhead.
Contrasting with if-added rules, a rule should be an if-need ed (lazy) rule if a knowledge slot
is empty and can be computed but computing it is not a high prio rity. These rules defer rule
checking to when some knowledge is explicitly requested and not found. When this happens,
the system checks to see if there is suitable knowledge in the knowledge base that can match the
predicates, and uses it to compute the requested knowledge i f so. After executing the rule action
that does the computation, the rule engine adds the new knowl edge to the knowledge base, which
can be reused to avoid further rule ﬁring if the same knowledg e is requested again in the future.
3.2 Rule Structure
We now give a detailed outline of how rules are structured in S cone and provide some examples.
Rules consist of several parts:
•Thevariables of a rule create placeholders where Scone elements can be plu gged into the
rule. This creates an abstraction where the rule can be appli ed to any valid elements, not
just to some speciﬁc individuals. For each variable, a Scone type constraint can be speci-
ﬁed such that an element must be an inferior of the speciﬁed ty pe to satisfy the rule. Each
variable can have at most one speciﬁed type constraint, thou gh specifying an intersection
type effectively allows any number of type constraints.
Some rule variables can also optionally be tagged as proper , signifying that only proper
Scone nodes can be substituted in for the variable (i.e. no ge neric role nodes). We will see
why this is needed later.
•The x-y-z-predicates of a rule deﬁne the relationships between different element s in the
rule. Each predicate consists of three elements in the form ( X Y Z). The Y element here
must be a role or relation, and the X and Z elements are variabl es or Scone elements. If Y
is a role, the predicate represents “X is a Y of Z.” If Y is a rela tion, the predicate represents
“statement X Y Z is true.” Each predicate must be true for the r ule to be satisﬁed.
•The action of a rule is executed when the rule is ﬁred and the predicates o f the rule are
satisﬁed for some elements in the knowledge base. The possib le actions of a rule are
slightly different for if-added and if-needed rules.
For if-added rules, the action can be arbitrary code that use s the variables deﬁned in
the rule. The rule will substitute the satisfying elements i nto the variables and execute
the code, causing either changes in the knowledge base or per forming some action in
the real world.
For if-needed rules, the action takes the form (X Y Z), where X is an arbitrary com-
putation, Y is an individual role node, and Z is a variable rep resenting the owner of
the desired value. The action is executed by carrying out com putation X and setting
it as the desired slot ﬁller “the Y of Z.”
13
A Btravel
vehicle airplaneﬂying
event
Figure 3.1: A diagram of the if-added ﬂying event rule with so me of the relevant elements. A
and B are drawn with dashed circles to indicate that they are p laceholders for other elements.
Solid lines indicate is-a links, and dashed lines indicate x -y-z links (in this case a role has-link).
The double lines indicate links that are created when the rul e action is ﬁred.
The variables with their type constraints together with the x-y-z-predicates form the LHS
predicates of the rule, and the action is the RHS of the rule. W e additionally place a constraint
on the x-y-z-predicates of a rule to make sure that the elemen ts in a rule are connected to each
other. If we consider the graph with the X and Z values as the ve rtices and an edge between X
and Z for each x-y-z-predicate, this graph must be connected for the rule to be well-deﬁned. For
example, a rule with four variables A, B, C, and D with only x-y -z-predicates “A is the mother
of B” and “C is the mother of D” is ill-deﬁned because variable s A and B are not connected
to variables C and D. If we allowed such rules, then any time we create a mother link, the new
mother link taken together with any other existing mother li nk would satisfy the rule, causing
an overabundance of rule ﬁrings. These kinds of rules also ma ke little conceptual sense, since
elements in a rule should be related to each other in some way.
We describe the following example rules using language to co nvey what the rules mean con-
ceptually. Code in Common Lisp to deﬁne the rules can be found in the Appendix.
3.2.1 If-added rule example
Consider an example if-added rule: if someone is traveling a nd the vehicle they are in is an
airplane, then that person is ﬂying. We represent {traveling}as an event type with a {travel
vehicle}role. The parts of this example rule would be as follows:
•There are two variables A and B that represent the travel event and the vehicle, and va riable
B has the type constraint “B is an airplane”.
•There is one x-y-z-predicate “B is the travel vehicle of A” that captures the relationship
between A and B.
•Theaction adds the link “A is a ﬂying event” to the knowledge base.
The portion of the knowledge base that would match with this r ule is visualized in Figure
3.1. Once this if-added rule is deﬁned and put into the system , the rule engine will start listening
to additions to the knowledge base. When it detects new knowl edge that could potentially match
certain elements to A and B in the predicates, it starts tryin g to check the rule and executes the
action if the predicates are satisﬁed.
14
One part of the rule to note is that we want to specify a type con straint for variable B but not
for variable A. The reason for this is that variables should o nly contain a type constraint if the
type of that variable is essential to the truth value of the ru le predicates. The x-y-z-predicates of
a rule place some implicit type constraints on the variables . For the example rule, the fact that
A is a{traveling}event and B is a{vehicle}can be inferred from the x-y-z-predicate. Knowing
that a candidate element for B is an airplane is essential for determining if A is a {ﬂying}event,
since if B was a different vehicle like a car, A would be a diffe rent kind of traveling event. On
the other hand, there is no need to specify any explicit type c onstraints for A, since the implicit
ones are enough to determine if A is a ﬂying event.
As a side note, the rule engine will still work if extraneous t ype constraints are speciﬁed,
just at the cost of potentially more work done. This is becaus e atrigger is created for each type
constraint that may be checked whenever new knowledge is add ed. See Section 4.1.1 for details
regarding rule triggers.
3.2.2 If-needed rule example
Now consider an example if-needed rule: if we want to know the duration of a meeting, and we
know that the start time and end time of that meeting are t1andt2, then we can compute the
duration as t2−t1. The parts of this rule would be as follows:
•There are three variables A, B, and C that represent the start time, end time, and the
meeting. Variables A and B should be tagged as proper to indicate that only proper values
should be substituted for them in the rule.
•There are two x-y-z-predicates “A is the start time of C” and “B is the end time of C.”
•Theaction computes B−A using the proper values for A and B and returns it as the answe r
“the duration of C.”
The parts of the rule are visualized in 3.2. After this if-nee ded rule is deﬁned, the system
remembers it as a possible way to compute the duration of the m eeting when requested. If the
duration of some meeting is requested, the system ﬁrst check s to see if a value exists for that
meeting, returning it if it does. If it does not, then the rule system will try to match knowledge
about the meeting to the rule, and if the matching is successf ul, will compute the requested
duration and add it to the knowledge base.
The reason variables A and B should be tagged as proper in this rule is to ensure that only
nodes with actual values are substituted in, since the rule a ction needs the values of A and B. A
role node can be created and given a type but not a speciﬁc valu e, for example by saying that the
start time of a meeting ends in :30 but the exact time is unknow n. This makes the start time of
that meeting a concrete element that is a subtype of {time ending in :30}, but trying to compute
the duration of that meeting would fail because there is no pr oper value for the start time of the
meeting.
15
A BC
start time end time duration
f(A,B) =B−A
Figure 3.2: A diagram of the if-needed meeting duration rule . The arrows from A and B to the
node labeled f(A,B)indicate that A and B will be used for the computation, and the double line
fromf(A,B)to “duration of C” represents the is-a link that will be creat ed and returned.
3.3 Recipe-Based Planner
The recipe-based planner, of which we have partial prototyp es but not yet a full implementation,
is based on Fahlman’s BUILD planner [5] adapted to the framew ork of Scone and episodic
knowledge representation described in Eris. BUILD describ es a ﬂexible planning system in the
setting of moving blocks around on a table. In the setting con sidered, the table starts out with
some conﬁguration of blocks, and the goal is to rearrange the blocks into some goal state without
causing any instability. The BUILD planner achieves this by breaking up the goal into subgoals
and planning out how to achieve each subgoal using different actions. If when planning it reaches
a state in which it cannot continue due to instability, it rec ursively backtracks to a previous state
and tries different actions. In this way, the planner can avo id getting stuck in error states and can
generally always ﬁnd options to make progress.
BUILD’s central capability of backtracking to previous sta tes and considering different al-
ternatives can be implemented effectively using Scone’s mu ltiple context system. In Scone,
information about the current state is stored in the active c ontext. When considering an action
to perform, the active context ﬁlls the {before-context}role of the action, and new information
about the resulting state will be stored in the {after-context}role of the action. The recipe-based
planner can consider what happens after performing this act ion by activating the {after-context}
and looking at the resulting state. If this eventually leads to an undesirable state where achieving
the subgoal is difﬁcult or impossible, then the planner can s imply reactivate the {before-context}
to revert the consequences of the action and try out other pos sible actions.
The way Scone stores episodic knowledge as described in Eris also guides the way the recipe-
based planner breaks down a goal into subgoals and tries alte rnative strategies for reaching dif-
ferent goals. Suppose the planner is trying to achieve the go al of going to the Pittsburgh airport.
This goal{go to the Pittsburgh airport }can be represented as an action type in Scone (i.e. this el-
ement is a subtype of {action}), and it can further have subtypes such as {drive to the Pittsburgh
16
airport}or{take the bus to the Pittsburgh airport }. The split action types in the is-a hierarchy
represent qualitatively different plans to take: driving t o the airport versus taking the bus each
require a particular set of considerations, and the two plan s are mutually exclusive.
Action types also have a part-of hierarchy induced by {part of}roles that correspond to
different subgoals in each plan. For example, the {driving to the Pittsburgh airport }action can
have parts such as {take the car keys},{put the car keys in the ignition },{take a left turn at so-
and-so street}, and so on. A different action has different parts and theref ore different subgoals,
like{take the bus to the Pittsburgh }has{go to the bus stop}and{pay the bus fare}as parts.
Each part of an action can have further parts until eventuall y the action reaches a base action such
as some motor movement that is easily carried out. If one of th e subgoals cannot be carried out
for whatever reason, then the planner tries a different set o f subgoals to unblock itself: if turning
left is impossible because the road is blocked due to constru ction, the planner can try to ﬁnd a
different path to drive. Failing that, the planner can decid e that the current action is impossible
to complete and try a different plan: if the car keys cannot be found, then driving is impossible
and a different method of going to the airport is required.
3.4 Implementation Status
The core structure of production rules has been implemented in code and added to the main
Scone engine. Scone is developed in Common Lisp, so we extend ed the engine with Common
Lisp code to implement production rules. We represent a prod uction rule as a Lisp structure
with components for each of its parts, including variables, predicates, and actions. If-added and
if-needed rules share the same underlying data structure. M ost importantly, we deﬁne two new
Lisp macros for creating new rules, one for creating if-adde d rules and one for creating if-needed
rules. These macros are intended to be used similarly to Scon e functions such as new-type
andnew-is-a that add knowledge to the knowledge base. Sample macro calls that deﬁne the
example rules above are provided in the Appendix.
Implementation of the recipe-based planner is beyond the sc ope of this research and left to
future work; we describe its design to provide context for th e goals of the production system
planner compared to the goals of the recipe-based planner.
Now that we have a framework for adding new rules to the Scone k nowledge base system,
we need a system for checking and ﬁring these rules. In the nex t section, we describe the rule
checking engine, which we have fully implemented in the Scon e engine.
17
18
Chapter 4
Rule-Checking Engine
4.1 Rule-Checking Components
Scone is a very large knowledge base, and the rules can refere nce any subset of elements in the
knowledge base, so some care must be taken in how rules are che cked to be satisﬁed. Constantly
checking all the rules for if they are satisﬁed is very wastef ul, since rules only become satisﬁed
once new knowledge is added, and then only a few rules (if any) would be satisﬁed. In addition,
trying to match every element naively to rule variables is ve ry inefﬁcient, since there are too
many elements to check.
To address the ﬁrst problem, whenever a rule is created, a set of rule “triggers” are created
and attached to all elements involved in the rule. These trig gers are then checked when new
knowledge is added for if-added rules and when a role value is requested for if-needed rules. To
address the second problem, the rule system carries out a rul e-checking search algorithm that
leverages Scone’s marker-passing operations to search for relevant elements that could satisfy
the rule.
4.1.1 Rule Triggers
If-added rules should only be checked when new knowledge is a dded to the knowledge base,
and if-needed rules should only be checked when a role value i s requested. Additionally, we
only want to check the subset of rules that could match with th e new knowledge or requested
role. To achieve this, each newly created rule should create triggers that control when to check
that particular rule. Three types of triggers are created: o ne for adding new is-a links, one for
adding new role or statement links, and one for accessing a ro le value. Each trigger is placed on
a Scone element using element properties, which are key-val ue pairs that each element can have.
The three types of triggers have slightly different forms to deal with the different ways they are
activated.
•Let R be an if-added rule with a variable X that has an is-a type constraint Y . When this rule
is deﬁned, a trigger of the form (R X) containing pointers to R and X is created and attached
to element Y . Conceptually, this trigger represents the fac t that any inferiors of element Y
could be substituted for variable X in rule R. All inferiors o f Y therefore virtually inherit
19
this rule trigger.
Suppose a new is-a link or eq link from node A to node B is create d. This link could cause
any rule attached to a trigger that B virtually inherits to be come satisﬁed. Therefore, we
perform an upscan on B to check if there are any triggers (R X) o n any superior of B.
Each such trigger is activated by substituting in A for varia ble X in rule R, then starting
the rule-checking search algorithm on R. A visualization of this kind of trigger activation
is provided in Figure 4.1.
•Let R be an if-added rule with an x-y-z-predicate (X Y Z), wher e Y is a role or relation
and X and Z are variables or nodes. When this rule is deﬁned, a t rigger containing pointers
to R, X, and Z is created and attached to element Y . This trigge r represents the fact that a
link (A B C) where B is an inferior of Y could match A with X and C w ith Z in rule R. All
inferiors of Y therefore virtually inherit this rule trigge r.
Suppose a new link (A B C) is created, where B is a role node or a r elation. If B is a role,
this link looks like “A is a B of C”, and if B is a relation, this l ink looks like the statement
“A B C”. We perform an upscan on B to check if there are any trigg ers (R X Z) that B
should inherit. If X is a Scone element in a trigger, we check i f A is an inferior of X, and
we do not activate the trigger if not. If X is a variable, we sub stitute A for X in R and allow
activation. We also do this check for Z and C. If activation of this trigger is not blocked and
A and C are substituted into their corresponding variables, then the rule-checking search
algorithm is then started on R. This matching is visualized i n Figure 4.2.
•Let R be an if-needed rule with action (X Y Z), where X is a compu tation, Y is a role,
and Z is a variable. When this rule is deﬁned, a trigger of the f orm (R Z) is created and
attached to element Y . This trigger represents that if we wan t to know the B of C where B
is an inferior of Y , then we could ﬁnd out by activating a rule b y substituting C for Z in R.
All inferiors of Y therefore virtually inherit this rule tri gger.
Suppose the value “the B of C” is requested, where B is a role no de. We perform an upscan
on B to check if there are any triggers (R Z) that B should inher it. Each trigger found is
activated by substituting C for variable Z in rule R and start ing the rule-checking search
algorithm on R. The substitution and resulting link created is visualized in Figure 4.3.
4.1.2 Rule Variable Substitution
One necessary component of rule-checking is the ability to s ubstitute a Scone element for a
variable in a rule. A rule R contains data about the variables in the rule, the type constraints on
those variables, the x-y-z-predicates of the rule, and the r ule action. When the system attempts
to substitute an element E for variable X in rule R, it must ﬁrs t validate that E is an inferior of
any type constraints on X and that any x-y-z-predicates invo lving X are satisﬁed by E. If any of
these are false, then the substitution fails and E cannot sat isfy the rule when substituted for X.
If substitution succeeds, then the rule stores E as the curre nt ﬁller for X. When all variables in a
rule are successfully substituted, the rule is satisﬁed and the action is ready to ﬁre using all the
stored elements.
20
Y (R X)
X
ABR
Figure 4.1: A visualization of an is-a type constraint trigg er. Y is above B in the is-a hierarchy,
and has a trigger attached to it with pointers to rule R and var iable X. Trigger activation is
performed by matching A with X.
Y (R X Z)
X Z
A B CR
Figure 4.2: A visualization of an x-y-z-predicate trigger. Y is above B in the is-a hierarchy, and
has a trigger attached to it with pointers to rule R and variab les X and Z. Trigger activation is
performed by matching A with X and C with Z.
Y (R Z)
X Z
B CR
Figure 4.3: A visualization of an if-needed rule trigger. Y i s above B in the is-a hierarchy, and
has a trigger attached to it with pointers to rule R and variab le Z. Trigger activation is performed
by matching C with Z. An is-a link is created between the resul ting computation X and “the B of
C” as part of the rule action.
21
procedure CHECK -RULE (R)
ifRhas an element substituted for each variable then
AddRto a queue to be ﬁred
return T
end if
Choose an x-y-z-predicate (X Y Z)ofRwith an element substituted for XorZ
Allocate a new marker m
ifXhas an element substituted for it then
Mark with mall elements Esuch that the predicate (X Y E)is satisﬁed
end if
ifZhas an element substituted for it then
Mark with mall elements Esuch that the predicate (E Y Z)is satisﬁed
end if
foreach element Emarked with mdo
R′←substitute Efor the unsubstituted variable XorZinR
ifany predicates in R′are false then
continue
end if
CHECK -RULE (R′)
end for
return NIL
end procedure
Figure 4.4: Rule-Checking Algorithm
4.1.3 Rule-Checking Search Algorithm
A rule starts to be checked when at least one element is substi tuted in for a variable in that rule.
This occurs when a trigger for a rule is activated as describe d previously. The next step is to ﬁnd a
set of Scone elements such that all of them can be substituted in for the rest of the variables while
satisfying all of the rule predicates. This is accomplished through a recursive search algorithm
that searches through possible elements using Scone marker operations.
At a high level, the algorithm starts by choosing an x-y-z-pr edicate that has just one variable
substituted with an element and one unsubstituted variable . It then uses Scone marker operations
to mark each element that can satisfy the predicate when subs tituting it in for the remaining
variable. If the remaining variable is marked as proper, the markers are then restricted to the
subset of elements that are proper using another marker oper ation. For each marked element, the
algorithm tries to substitute the element into the rule. If s ubstitution fails, the algorithm proceeds
to the next marked element. If there are no more marked elemen ts, the algorithm returns NIL.
If substitution succeeds, the algorithm recurses to try to ﬁ nd an element for another variable in
the rule. If the algorithm successfully ﬁnds elements for al l the variables in the rule, it executes
the action of the rule using the elements it found. The full al gorithm pseudocode can be found in
Figure 4.4.
22
Note that our constraint that the x-y-z-predicates should f orm a connected graph ensures
this algorithm’s correctness in ﬁnding all possible sets of elements that could satisfy the rule.
The algorithm essentially repeatedly chooses an arbitrary edge connecting a substituted variable
with an unsubstituted variable and ﬁnds an element that can b e substituted. Each of these steps
of ﬁnding suitable elements is relatively fast, since it onl y involves a single marker operation
starting from a substituted element. Since one marker pair i s allocated at each recursion, the
recursion depth is limited by the number of marker pairs avai lable. This is not an issue because
the recursion depth is equal to the number of x-y-z-predicat es which is typically no more than
three or four, and the number of marker pairs available is gen erally around fourteen.
In some cases, adding a piece of knowledge can cause multiple rules to ﬁre. When this
happens, we add each satisﬁed rule to a queue and ﬁre them sequ entially. This sequential ﬁring
after triggers are checked makes the algorithm comparable t o the algorithm used by ACT-R.
Rules are ﬁred in order of when their triggers are checked, wh ich is generally starting from
triggers attached to elements at the bottom of the hierarchy and working their way up, though
this order is not strictly deﬁned. We adopt this method of seq uential ﬁring to ensure that rule
ﬁring is deterministic and consistent, letting Scone take c are of preventing any rule action that
would add contradictory knowledge to the knowledge base.
4.2 End-to-end Example Rule Firing
To illustrate how Scone’s production system works in practi ce, we step through Scone’s processes
for checking and ﬁring an example rule. We use the rule given e arlier in Section 3.2.2 but phrased
as an if-added rule instead of an if-needed rule. Note that in some cases such as this one, a rule
can be deﬁned as either an if-added rule or as an if-needed rul e, and choosing which kind of rule
depends on how immediately we want the result of the rule to be updated in the knowledge base.
As a reminder, the parts of the rule are as follows:
•There are three variables A, B, and C that represent the start time, end time, and the
meeting.
•There are two x-y-z-predicates “A is the start time of C” and “B is the end time of C.”
•Theaction adds the link “B−A is the duration of C” to the knowledge base.
Deﬁning this if-added rule adds triggers (R A C) to role {start time}and (R B C) to role {end
time}for the x-y-z-predicates. Afterwards, any additions to the knowledge base involving these
roles cause the triggers to be checked.
This rule is now deﬁned for an abstract set of elements that wo uld satisfy all the rule precon-
ditions. To see how the rule is specialized to ﬁre for speciﬁc individuals, suppose we create a
new individual{meeting 27}that represents a speciﬁc meeting. Now suppose we ﬁrst add th e
link “10:30 AM is the start time of meeting 27” to the knowledg e base. This causes an upscan
on{start time}to ﬁnd inherited rule triggers that could be activated. Ther e is in fact a trigger
(R A C) on{start time}, so the rule engine checks if {10:30 AM}can be substituted for A and
{meeting 27}can be substituted for C. There are no explicit type constrai nts on either A or C and
no other violated predicates, so substitution is successfu l and the trigger is activated, as shown in
Figure 4.5.
23
start time (R A C)
A C B
10:30 AM meeting 27Rend time (R B C)
B C A
11:30 AM meeting 27R
Figure 4.5: A visualization of two trigger activations for t he meeting example rule, one for each
of the x-y-z role predicates.
After this trigger is activated, variables A and C in R are sub stituted, but variable B is not, so
it is the job of the search algorithm to ﬁnd a suitable element for B. It sees that there is a partially
substituted x-y-z-predicate “B is the end time of meeting 27 ” in the rule, so it allocates a marker
pair and marks all elements E that satisﬁes “E is the end time o f meeting 27.” (For this particular
rule, since variable B is marked as proper, the algorithm fur ther restricts the marked elements to
only proper elements.) At this point, there are in fact no suc h elements that can be marked, so
the algorithm returns knowing the rule is not satisﬁed. Conc eptually, we currently only know the
start time of meeting 27 but not the end time, so as expected we cannot yet compute the duration
of the meeting.
Suppose we ﬁnd out that “11:30 AM is the end time of meeting 27” and add this to the
knowledge base. This causes an upscan on {end time}to ﬁnd inherited rule triggers, which ﬁnds
trigger (R B C) on {end time}. Activating the rule trigger by substituting {11:30 AM}for B
and{meeting 27}for C (as shown in Figure 4.5) is successful because there are no violated
predicates, so the search algorithm looks for an element for the unsubstituted variable A.
The algorithm ﬁnds the partially substituted x-y-z-predic ate “A is the start time of meeting
27” so it allocates a marker pair and marks all elements E such that “E is the start time of
meeting 27” (again only marking proper elements). This time , it marks{10:30 AM}given that
“10:30 AM is the start time of meeting 27” is in the knowledge b ase. For each marked element
E, the rule engine tries substituting E for B in R, so it tries s ubstituting{10:30 AM}for B in
R. This substitution does not violate any type constraints o r x-y-z-predicates, so substitution is
successful.
At this point, the rule has elements substituted for all of it s variables. This means the rule is
satisﬁed for this particular set of individuals, so the rule action is ﬁred.{11:30 AM}−{ 10:30
AM}is computed, yielding {1 hour}, and the knowledge “1 hour is the duration of meeting
27” is added to the knowledge base. This new knowledge could c ause rules with triggers that
{duration}inherits to ﬁre, if any are currently deﬁned.
The process of production rule ﬁring illustrates how Scone c an carry out automatic thinking
when it gains new knowledge. It only checks rules when it need s to, and it only checks the
24
speciﬁc rules that need to be checked, thanks to the rule trig ger mechanism. Using the search
algorithm, it is able to fetch the relevant knowledge to chec k if a rule is satisﬁed.
To elaborate a little more on the choice of making this rule ea ger or lazy, one reason to make
it eager would be if the duration of a meeting has a direct inﬂu ence on the decision of whether
to go to that meeting. For example, suppose we have another if -added rule representing “if a
meeting is at most 2 hours long, then decide to go to the meetin g” with the default decision to
not go to any meeting over two hours long. We want this additio nal rule to ﬁre as soon as we
know what the duration of a meeting is, and we also want it to ﬁr e as soon as we have enough
information to ﬁnd out the duration of a meeting. The ﬁrst rul e provides a way to ﬁgure out the
duration of a meeting, so deﬁning it as an if-added rule makes sense.
4.2.1 If-needed Example
We could also have reasonably deﬁned the previous rule for co mputing the duration of a meeting
as an if-needed rule. We would want to do so if we wanted the abi lity to compute this value when
someone asks what the duration of {meeting 27}is, but do not urgently need the duration of any
meeting. The structure of the rule would be essentially iden tical, but checking the rule would be
done differently. Instead of adding two if-added triggers, deﬁning the rule as an if-needed rule
adds one trigger (R C) to role node {duration}.
If-needed rules are not checked until a value is explicitly r equested, so adding knowledge
“10:30 AM is the start time of meeting 27” and “11:30 AM is the e nd time of meeting 27”
should not activate any triggers. The absence of any inherit ed triggers on{start time}and{end
time}ensures this behavior. Once the value for the slot ﬁller {the duration of meeting 27 }
is requested, an upscan is performed on role node {duration}, which ﬁnds trigger (R C). This
trigger is activated by substituting {meeting 27}for C in R, which is successful because it doesn’t
violate any predicates.
The search algorithm now looks for elements for variables A a nd B. Both x-y-z-predicates
are partially substituted, so one of them can be arbitrarily chosen, say “A is the start time of
meeting 27.” Skipping the details of the marker passing and s ubstitution, the algorithm ﬁnds that
{10:30 AM}can be substituted for A in R. Then, the algorithm looks for an element C that can
satisfy “C is the end time of meeting 27.” It ﬁnds element {11:30 AM}and substitutes it in for
C in R.
Now that all variables have been substituted, the rule actio n “B−A is the duration of B” can
be ﬁred. The computation of this rule action returns the valu e{1 hour}. The rule action adds
the computed link “1 hour is the duration of meeting 27” to the knowledge base and returns {1
hour}as the requested slot ﬁller. Note that after this rule action executes once, the next time {the
duration of meeting 27 }is requested, the knowledge already exists in the knowledge base, so
there is no need to check the rule again.
25
26
Chapter 5
Conclusion and Future Work
In this thesis, we proposed a design for if-added and if-need ed production rules that are com-
patible with the Scone knowledge base system. We also implem ented triggers and methods to
check efﬁciently if rules are satisﬁed. Our work primarily f alls under the “rule-based planner”
we have in mind for Scone that performs low-level automatic t hinking in response to added or
requested knowledge. We provided an outline of the design of the “recipe-based planner” to
provide context for the design goals of both kinds of planner s.
Future research into production systems for Scone could ext end the capabilities of production
rules in various ways. One extension is supporting if-remov ed rules that would contain negative
type constraints in the rule predicates, such as “A is not an e lephant.” These rules would ﬁre
when links are removed or canceled. Supporting this would in volve using Scone’s cancel-link
capabilities, and ensuring logically consistent behavior would be a challenge. We would also
want to apply the rule engine to a much larger knowledge base w ith a large collection of rules to
reveal any potential scaling or consistency issues.
One other possibility for rule checking is rumination , a technique used by Learning Reader
to perform off-line inferences to learn from natural langua ge [9]. In the context of Scone, if the
system is currently processing a low-priority rule but need s to spend resources on other higher
priority tasks, it can put off checking the rule until some po int in the future when it has resources
to spare. The unﬁnished rule is added to a queue to be processe d later. During rumination, the
system considers the queue of unﬁnished rules and processes some of them so they actually ﬁre
and update the knowledge base.
An important future research goal is the implementation of t he “recipe-based planner” for
Scone that would break up a goal into subgoals and plan out how to achieve each subgoal by
considering different options with multiple contexts. Tog ether with the rule-based planner, these
planners would guide an intelligent agent to make decisions in order to reach a deﬁned goal.
Simpler and more automatic ways to deﬁne rules, through stru ctured or unstructured natural
language, is an interesting direction for research. One exa mple is a more declarative form for
deﬁning rules using structured language, such as “the start time plus the duration of a meeting
equals the end time of that meeting.” The goal would be for thi s declarative form to create three
rules, one for computing each of the start time, duration, an d end time of a meeting given the
other two values. There is ongoing research on automaticall y adding knowledge to the Scone
knowledge base from external sources of unstructured natur al language sentences, and this re-
27
search could eventually be extended to adding production ru les automatically as well.
Finally, a way to learn production rules automatically may b e a desirable long-term goal,
though possibly out of scope of the capabilities of Scone. So ar and ACT-R describe methods
of learning production rules automatically [1, 12], though they generally involve some external
feedback or input from the environment. One method of learni ng from Soar is called chunking,
where new production rules are learned when the system reach es an impasse and no existing
production rules apply. In this case, Soar creates a new subg oal to resolve the impasse and
creates a new “chunk” rule to avoid future impasses in simila r situations. In Scone, the recipe-
based planner would take care of planning through such impas ses, and it could implement a
similar method of learning new helper production rules.
28
Bibliography
[1] John R Anderson. Act: A simple theory of complex cognitio n.American psychologist , 51
(4):355, 1996.
[2] John R. (John Robert) Anderson. How can the human mind occur in the physical universe?
Oxford series on cognitive models and architectures. Oxfor d University Press, Oxford ;,
2007. ISBN 0195324250.
[3] Jelmer Borst, Niels Taatgen, and Hedderik Rijn. The prob lem state: A cognitive bottleneck
in multitasking. Journal of experimental psychology. Learning, memory, and cognition , 36:
363–82, 03 2010. doi: 10.1037/a0018106.
[4] Ivan Bratko. Prolog programming for artiﬁcial intelligence . Pearson education, 2001.
[5] Scott Elliott Fahlman. A planning system for robot const ruction tasks. Artiﬁcial Intel-
ligence , 5(1):1–49, 1974. ISSN 0004-3702. doi: https://doi.org/1 0.1016/0004-3702(74)
90008-3. URL https://www.sciencedirect.com/science/article/pii/
0004370274900083 .
[6] Scott E Fahlman. Marker-passing inference in the scone k nowledge-base system. In In-
ternational Conference on Knowledge Science, Engineering and Management , pages 114–
126. Springer, 2006.
[7] Scott E Fahlman. Eris: Episodic representation and reas oning in scone. Technical report,
Citeseer, 2014.
[8] Scott E Fahlman. Tutorial information on scone, 2018. UR Lhttps://fahlman-
knowledge-nuggets.quora.com/Tutorial-Information-on -Scone .
[Online; accessed 18-April-2021].
[9] Kenneth D Forbus, Christopher Riesbeck, Lawrence Birnb aum, Kevin Livingston, Ab-
hishek Sharma, and Leo Ureel. Integrating natural language , knowledge representation and
reasoning, and analogical processing to learn by reading. I nProceedings of the National
Conference on Artiﬁcial Intelligence , volume 22, page 1542. Menlo Park, CA; Cambridge,
MA; London; AAAI Press; MIT Press; 1999, 2007.
[10] Charles L Forgy. Rete: A fast algorithm for the many patt ern/many object pattern match
problem. In Readings in Artiﬁcial Intelligence and Databases , pages 547–559. Elsevier,
1989.
[11] Ivan Herman. W3c semantic web activity, 2013. URL https://www.w3.org/2001/
sw/.
29
[12] John E Laird. The Soar cognitive architecture . MIT press, 2019.
[13] Jill Fain Lehman, John Laird, Paul Rosenbloom, et al. A g entle introduction to soar, an
architecture for human cognition: 2006 update. University of Michigan , pages 1–37, 2006.
[14] Allen Newell. Soar as a uniﬁed theory of cognition: Issu es and explanations. Behavioral
and Brain Sciences , 15(3):464–492, 1992.
[15] Alessandro Oltramari and Christian Lebiere. Pursuing artiﬁcial general intelligence by
leveraging the knowledge capabilities of act-r. In International Conference on Artiﬁcial
General Intelligence , pages 199–208. Springer, 2012.
30
Appendix
We have implemented the production rule system in Common Lis p in the main Scone engine1.
There are two new user-level macros that are used to add new if -added rules and if-needed rules
to the knowledge base. new-if-added-rule is a macro that takes bindings, x-y-z-preds, and
any number of body forms as arguments. new-if-needed-rule takes bindings, x-y-z-preds,
and an action as arguments.
Each binding is either a single variable or a list containing a variable and optional keyword
arguments:superior and:proper . Each x-y-z-predicate is a three-element list where the
second element is a role or relation. For if-added rules, the action is arbitrary code deﬁned in the
remainder of the body forms. For if-needed rules, the action is of the form (X Y Z) where X is a
computation, Y is an individual role node, and Z is a variable deﬁned in the bindings.
The example if-added rule described in Section 3.2.1 can be d eﬁned using the macro as
follows:
(new-if-added-rule (a (b :superior {airplane}))
((b {travel vehicle} a))
(new-is-a a {flying event}))
Running this macro adds this rule to the knowledge base and ad ds triggers for this rule to
{airplane}and{travel vehicle}. Assuming the Scone elements are deﬁned correctly, we can
test that the rule ﬁres correctly with the following snippet of code:
(new-indv {my trip} {traveling event})
(new-indv {my vehicle} {airplane})
(x-is-a-y-of-z {my vehicle} {travel vehicle} {my trip})
(assert (simple-is-x-a-y? {my trip} {flying event}))
This code creates a new individual trip, a new individual veh icle that is an airplane, and sets
{my vehicle}as the{travel vehicle}of the trip. The assertion succeeds, indicating that the rul e
succesfully ﬁred and added the link “my trip is a ﬂying event” to the knowledge base.
The example if-needed rule described in Section 3.2.2 can be deﬁned using the macro as
follows:
(new-if-needed-rule ((a :proper t) (b :proper t) c)
((a {start time} c)
1The code for the production rule engine is currently hosted a thttps://github.com/jchen1352/
scone/tree/develop
31
(b {end time} c))
((scone-subtract b a) {duration} c))
For simplicity, assume {start time}and{end time}are Scone numbers representing seconds
since the epoch, and scone-subtract is an appropriately deﬁned Lisp function that can
subtract two Scone time elements. We can test that the rule ﬁr es correctly with the following
snippet of code:
(new-indv {my meeting} {meeting})
(x-is-the-y-of-z {1609459200} {start time} {my meeting})
(x-is-the-y-of-z {1609462800} {end time} {my meeting})
(assert (is-x-eq-y? {3600} (the-x-of-y {duration} {my mee ting})))
This code creates a new individual meeting and sets its start time and end time. the-x-of-y
is responsible for checking potential if-needed rules, and the assertion succeeds indicating that
the if-needed rule successfully ﬁred and added the link “360 0 (seconds) is the duration of my
meeting” to the knowledge base.
32